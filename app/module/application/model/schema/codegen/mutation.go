// Code generated by ent, DO NOT EDIT.

package codegen

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/wangxg422/XishangOS-backend/app/module/application/model/schema/codegen/appinstance"
	"github.com/wangxg422/XishangOS-backend/app/module/application/model/schema/codegen/apppackage"
	"github.com/wangxg422/XishangOS-backend/app/module/application/model/schema/codegen/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppInstance = "AppInstance"
	TypeAppPackage  = "AppPackage"
)

// AppInstanceMutation represents an operation that mutates the AppInstance nodes in the graph.
type AppInstanceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete_at           *time.Time
	status              *int8
	addstatus           *int8
	remark              *string
	del_flag            *int8
	adddel_flag         *int8
	instance_name       *string
	instance_code       *string
	instance_package    *int64
	addinstance_package *int64
	instance_icon       *string
	instance_address    *string
	instance_type       *int8
	addinstance_type    *int8
	installer           *int64
	addinstaller        *int64
	desc                *string
	clearedFields       map[string]struct{}
	installFrom         *int64
	clearedinstallFrom  bool
	done                bool
	oldValue            func(context.Context) (*AppInstance, error)
	predicates          []predicate.AppInstance
}

var _ ent.Mutation = (*AppInstanceMutation)(nil)

// appinstanceOption allows management of the mutation configuration using functional options.
type appinstanceOption func(*AppInstanceMutation)

// newAppInstanceMutation creates new mutation for the AppInstance entity.
func newAppInstanceMutation(c config, op Op, opts ...appinstanceOption) *AppInstanceMutation {
	m := &AppInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAppInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppInstanceID sets the ID field of the mutation.
func withAppInstanceID(id int64) appinstanceOption {
	return func(m *AppInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *AppInstance
		)
		m.oldValue = func(ctx context.Context) (*AppInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppInstance sets the old AppInstance of the mutation.
func withAppInstance(node *AppInstance) appinstanceOption {
	return func(m *AppInstanceMutation) {
		m.oldValue = func(context.Context) (*AppInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("codegen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppInstance entities.
func (m *AppInstanceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppInstanceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppInstanceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppInstanceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[appinstance.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppInstanceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, appinstance.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppInstanceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appinstance.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppInstanceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appinstance.FieldUpdatedAt)
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppInstanceMutation) SetDeleteAt(t time.Time) {
	m.delete_at = &t
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppInstanceMutation) DeleteAt() (r time.Time, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldDeleteAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// ClearDeleteAt clears the value of the "delete_at" field.
func (m *AppInstanceMutation) ClearDeleteAt() {
	m.delete_at = nil
	m.clearedFields[appinstance.FieldDeleteAt] = struct{}{}
}

// DeleteAtCleared returns if the "delete_at" field was cleared in this mutation.
func (m *AppInstanceMutation) DeleteAtCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldDeleteAt]
	return ok
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppInstanceMutation) ResetDeleteAt() {
	m.delete_at = nil
	delete(m.clearedFields, appinstance.FieldDeleteAt)
}

// SetStatus sets the "status" field.
func (m *AppInstanceMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AppInstanceMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AppInstanceMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AppInstanceMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AppInstanceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[appinstance.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppInstanceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppInstanceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, appinstance.FieldStatus)
}

// SetRemark sets the "remark" field.
func (m *AppInstanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AppInstanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AppInstanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[appinstance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AppInstanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AppInstanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, appinstance.FieldRemark)
}

// SetDelFlag sets the "del_flag" field.
func (m *AppInstanceMutation) SetDelFlag(i int8) {
	m.del_flag = &i
	m.adddel_flag = nil
}

// DelFlag returns the value of the "del_flag" field in the mutation.
func (m *AppInstanceMutation) DelFlag() (r int8, exists bool) {
	v := m.del_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDelFlag returns the old "del_flag" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldDelFlag(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelFlag: %w", err)
	}
	return oldValue.DelFlag, nil
}

// AddDelFlag adds i to the "del_flag" field.
func (m *AppInstanceMutation) AddDelFlag(i int8) {
	if m.adddel_flag != nil {
		*m.adddel_flag += i
	} else {
		m.adddel_flag = &i
	}
}

// AddedDelFlag returns the value that was added to the "del_flag" field in this mutation.
func (m *AppInstanceMutation) AddedDelFlag() (r int8, exists bool) {
	v := m.adddel_flag
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelFlag clears the value of the "del_flag" field.
func (m *AppInstanceMutation) ClearDelFlag() {
	m.del_flag = nil
	m.adddel_flag = nil
	m.clearedFields[appinstance.FieldDelFlag] = struct{}{}
}

// DelFlagCleared returns if the "del_flag" field was cleared in this mutation.
func (m *AppInstanceMutation) DelFlagCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldDelFlag]
	return ok
}

// ResetDelFlag resets all changes to the "del_flag" field.
func (m *AppInstanceMutation) ResetDelFlag() {
	m.del_flag = nil
	m.adddel_flag = nil
	delete(m.clearedFields, appinstance.FieldDelFlag)
}

// SetInstanceName sets the "instance_name" field.
func (m *AppInstanceMutation) SetInstanceName(s string) {
	m.instance_name = &s
}

// InstanceName returns the value of the "instance_name" field in the mutation.
func (m *AppInstanceMutation) InstanceName() (r string, exists bool) {
	v := m.instance_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceName returns the old "instance_name" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstanceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceName: %w", err)
	}
	return oldValue.InstanceName, nil
}

// ResetInstanceName resets all changes to the "instance_name" field.
func (m *AppInstanceMutation) ResetInstanceName() {
	m.instance_name = nil
}

// SetInstanceCode sets the "instance_code" field.
func (m *AppInstanceMutation) SetInstanceCode(s string) {
	m.instance_code = &s
}

// InstanceCode returns the value of the "instance_code" field in the mutation.
func (m *AppInstanceMutation) InstanceCode() (r string, exists bool) {
	v := m.instance_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceCode returns the old "instance_code" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstanceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceCode: %w", err)
	}
	return oldValue.InstanceCode, nil
}

// ResetInstanceCode resets all changes to the "instance_code" field.
func (m *AppInstanceMutation) ResetInstanceCode() {
	m.instance_code = nil
}

// SetInstancePackage sets the "instance_package" field.
func (m *AppInstanceMutation) SetInstancePackage(i int64) {
	m.instance_package = &i
	m.addinstance_package = nil
}

// InstancePackage returns the value of the "instance_package" field in the mutation.
func (m *AppInstanceMutation) InstancePackage() (r int64, exists bool) {
	v := m.instance_package
	if v == nil {
		return
	}
	return *v, true
}

// OldInstancePackage returns the old "instance_package" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstancePackage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstancePackage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstancePackage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstancePackage: %w", err)
	}
	return oldValue.InstancePackage, nil
}

// AddInstancePackage adds i to the "instance_package" field.
func (m *AppInstanceMutation) AddInstancePackage(i int64) {
	if m.addinstance_package != nil {
		*m.addinstance_package += i
	} else {
		m.addinstance_package = &i
	}
}

// AddedInstancePackage returns the value that was added to the "instance_package" field in this mutation.
func (m *AppInstanceMutation) AddedInstancePackage() (r int64, exists bool) {
	v := m.addinstance_package
	if v == nil {
		return
	}
	return *v, true
}

// ResetInstancePackage resets all changes to the "instance_package" field.
func (m *AppInstanceMutation) ResetInstancePackage() {
	m.instance_package = nil
	m.addinstance_package = nil
}

// SetInstanceIcon sets the "instance_icon" field.
func (m *AppInstanceMutation) SetInstanceIcon(s string) {
	m.instance_icon = &s
}

// InstanceIcon returns the value of the "instance_icon" field in the mutation.
func (m *AppInstanceMutation) InstanceIcon() (r string, exists bool) {
	v := m.instance_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceIcon returns the old "instance_icon" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstanceIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceIcon: %w", err)
	}
	return oldValue.InstanceIcon, nil
}

// ClearInstanceIcon clears the value of the "instance_icon" field.
func (m *AppInstanceMutation) ClearInstanceIcon() {
	m.instance_icon = nil
	m.clearedFields[appinstance.FieldInstanceIcon] = struct{}{}
}

// InstanceIconCleared returns if the "instance_icon" field was cleared in this mutation.
func (m *AppInstanceMutation) InstanceIconCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldInstanceIcon]
	return ok
}

// ResetInstanceIcon resets all changes to the "instance_icon" field.
func (m *AppInstanceMutation) ResetInstanceIcon() {
	m.instance_icon = nil
	delete(m.clearedFields, appinstance.FieldInstanceIcon)
}

// SetInstanceAddress sets the "instance_address" field.
func (m *AppInstanceMutation) SetInstanceAddress(s string) {
	m.instance_address = &s
}

// InstanceAddress returns the value of the "instance_address" field in the mutation.
func (m *AppInstanceMutation) InstanceAddress() (r string, exists bool) {
	v := m.instance_address
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceAddress returns the old "instance_address" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstanceAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceAddress: %w", err)
	}
	return oldValue.InstanceAddress, nil
}

// ClearInstanceAddress clears the value of the "instance_address" field.
func (m *AppInstanceMutation) ClearInstanceAddress() {
	m.instance_address = nil
	m.clearedFields[appinstance.FieldInstanceAddress] = struct{}{}
}

// InstanceAddressCleared returns if the "instance_address" field was cleared in this mutation.
func (m *AppInstanceMutation) InstanceAddressCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldInstanceAddress]
	return ok
}

// ResetInstanceAddress resets all changes to the "instance_address" field.
func (m *AppInstanceMutation) ResetInstanceAddress() {
	m.instance_address = nil
	delete(m.clearedFields, appinstance.FieldInstanceAddress)
}

// SetInstanceType sets the "instance_type" field.
func (m *AppInstanceMutation) SetInstanceType(i int8) {
	m.instance_type = &i
	m.addinstance_type = nil
}

// InstanceType returns the value of the "instance_type" field in the mutation.
func (m *AppInstanceMutation) InstanceType() (r int8, exists bool) {
	v := m.instance_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceType returns the old "instance_type" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstanceType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceType: %w", err)
	}
	return oldValue.InstanceType, nil
}

// AddInstanceType adds i to the "instance_type" field.
func (m *AppInstanceMutation) AddInstanceType(i int8) {
	if m.addinstance_type != nil {
		*m.addinstance_type += i
	} else {
		m.addinstance_type = &i
	}
}

// AddedInstanceType returns the value that was added to the "instance_type" field in this mutation.
func (m *AppInstanceMutation) AddedInstanceType() (r int8, exists bool) {
	v := m.addinstance_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearInstanceType clears the value of the "instance_type" field.
func (m *AppInstanceMutation) ClearInstanceType() {
	m.instance_type = nil
	m.addinstance_type = nil
	m.clearedFields[appinstance.FieldInstanceType] = struct{}{}
}

// InstanceTypeCleared returns if the "instance_type" field was cleared in this mutation.
func (m *AppInstanceMutation) InstanceTypeCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldInstanceType]
	return ok
}

// ResetInstanceType resets all changes to the "instance_type" field.
func (m *AppInstanceMutation) ResetInstanceType() {
	m.instance_type = nil
	m.addinstance_type = nil
	delete(m.clearedFields, appinstance.FieldInstanceType)
}

// SetInstaller sets the "installer" field.
func (m *AppInstanceMutation) SetInstaller(i int64) {
	m.installer = &i
	m.addinstaller = nil
}

// Installer returns the value of the "installer" field in the mutation.
func (m *AppInstanceMutation) Installer() (r int64, exists bool) {
	v := m.installer
	if v == nil {
		return
	}
	return *v, true
}

// OldInstaller returns the old "installer" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldInstaller(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstaller: %w", err)
	}
	return oldValue.Installer, nil
}

// AddInstaller adds i to the "installer" field.
func (m *AppInstanceMutation) AddInstaller(i int64) {
	if m.addinstaller != nil {
		*m.addinstaller += i
	} else {
		m.addinstaller = &i
	}
}

// AddedInstaller returns the value that was added to the "installer" field in this mutation.
func (m *AppInstanceMutation) AddedInstaller() (r int64, exists bool) {
	v := m.addinstaller
	if v == nil {
		return
	}
	return *v, true
}

// ClearInstaller clears the value of the "installer" field.
func (m *AppInstanceMutation) ClearInstaller() {
	m.installer = nil
	m.addinstaller = nil
	m.clearedFields[appinstance.FieldInstaller] = struct{}{}
}

// InstallerCleared returns if the "installer" field was cleared in this mutation.
func (m *AppInstanceMutation) InstallerCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldInstaller]
	return ok
}

// ResetInstaller resets all changes to the "installer" field.
func (m *AppInstanceMutation) ResetInstaller() {
	m.installer = nil
	m.addinstaller = nil
	delete(m.clearedFields, appinstance.FieldInstaller)
}

// SetDesc sets the "desc" field.
func (m *AppInstanceMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AppInstanceMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the AppInstance entity.
// If the AppInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstanceMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *AppInstanceMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[appinstance.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AppInstanceMutation) DescCleared() bool {
	_, ok := m.clearedFields[appinstance.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AppInstanceMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, appinstance.FieldDesc)
}

// SetInstallFromID sets the "installFrom" edge to the AppPackage entity by id.
func (m *AppInstanceMutation) SetInstallFromID(id int64) {
	m.installFrom = &id
}

// ClearInstallFrom clears the "installFrom" edge to the AppPackage entity.
func (m *AppInstanceMutation) ClearInstallFrom() {
	m.clearedinstallFrom = true
}

// InstallFromCleared reports if the "installFrom" edge to the AppPackage entity was cleared.
func (m *AppInstanceMutation) InstallFromCleared() bool {
	return m.clearedinstallFrom
}

// InstallFromID returns the "installFrom" edge ID in the mutation.
func (m *AppInstanceMutation) InstallFromID() (id int64, exists bool) {
	if m.installFrom != nil {
		return *m.installFrom, true
	}
	return
}

// InstallFromIDs returns the "installFrom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstallFromID instead. It exists only for internal usage by the builders.
func (m *AppInstanceMutation) InstallFromIDs() (ids []int64) {
	if id := m.installFrom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstallFrom resets all changes to the "installFrom" edge.
func (m *AppInstanceMutation) ResetInstallFrom() {
	m.installFrom = nil
	m.clearedinstallFrom = false
}

// Where appends a list predicates to the AppInstanceMutation builder.
func (m *AppInstanceMutation) Where(ps ...predicate.AppInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppInstance).
func (m *AppInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppInstanceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, appinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appinstance.FieldUpdatedAt)
	}
	if m.delete_at != nil {
		fields = append(fields, appinstance.FieldDeleteAt)
	}
	if m.status != nil {
		fields = append(fields, appinstance.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, appinstance.FieldRemark)
	}
	if m.del_flag != nil {
		fields = append(fields, appinstance.FieldDelFlag)
	}
	if m.instance_name != nil {
		fields = append(fields, appinstance.FieldInstanceName)
	}
	if m.instance_code != nil {
		fields = append(fields, appinstance.FieldInstanceCode)
	}
	if m.instance_package != nil {
		fields = append(fields, appinstance.FieldInstancePackage)
	}
	if m.instance_icon != nil {
		fields = append(fields, appinstance.FieldInstanceIcon)
	}
	if m.instance_address != nil {
		fields = append(fields, appinstance.FieldInstanceAddress)
	}
	if m.instance_type != nil {
		fields = append(fields, appinstance.FieldInstanceType)
	}
	if m.installer != nil {
		fields = append(fields, appinstance.FieldInstaller)
	}
	if m.desc != nil {
		fields = append(fields, appinstance.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appinstance.FieldCreatedAt:
		return m.CreatedAt()
	case appinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case appinstance.FieldDeleteAt:
		return m.DeleteAt()
	case appinstance.FieldStatus:
		return m.Status()
	case appinstance.FieldRemark:
		return m.Remark()
	case appinstance.FieldDelFlag:
		return m.DelFlag()
	case appinstance.FieldInstanceName:
		return m.InstanceName()
	case appinstance.FieldInstanceCode:
		return m.InstanceCode()
	case appinstance.FieldInstancePackage:
		return m.InstancePackage()
	case appinstance.FieldInstanceIcon:
		return m.InstanceIcon()
	case appinstance.FieldInstanceAddress:
		return m.InstanceAddress()
	case appinstance.FieldInstanceType:
		return m.InstanceType()
	case appinstance.FieldInstaller:
		return m.Installer()
	case appinstance.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appinstance.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	case appinstance.FieldStatus:
		return m.OldStatus(ctx)
	case appinstance.FieldRemark:
		return m.OldRemark(ctx)
	case appinstance.FieldDelFlag:
		return m.OldDelFlag(ctx)
	case appinstance.FieldInstanceName:
		return m.OldInstanceName(ctx)
	case appinstance.FieldInstanceCode:
		return m.OldInstanceCode(ctx)
	case appinstance.FieldInstancePackage:
		return m.OldInstancePackage(ctx)
	case appinstance.FieldInstanceIcon:
		return m.OldInstanceIcon(ctx)
	case appinstance.FieldInstanceAddress:
		return m.OldInstanceAddress(ctx)
	case appinstance.FieldInstanceType:
		return m.OldInstanceType(ctx)
	case appinstance.FieldInstaller:
		return m.OldInstaller(ctx)
	case appinstance.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown AppInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appinstance.FieldDeleteAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	case appinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appinstance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case appinstance.FieldDelFlag:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelFlag(v)
		return nil
	case appinstance.FieldInstanceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceName(v)
		return nil
	case appinstance.FieldInstanceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceCode(v)
		return nil
	case appinstance.FieldInstancePackage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstancePackage(v)
		return nil
	case appinstance.FieldInstanceIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceIcon(v)
		return nil
	case appinstance.FieldInstanceAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceAddress(v)
		return nil
	case appinstance.FieldInstanceType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceType(v)
		return nil
	case appinstance.FieldInstaller:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstaller(v)
		return nil
	case appinstance.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown AppInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, appinstance.FieldStatus)
	}
	if m.adddel_flag != nil {
		fields = append(fields, appinstance.FieldDelFlag)
	}
	if m.addinstance_package != nil {
		fields = append(fields, appinstance.FieldInstancePackage)
	}
	if m.addinstance_type != nil {
		fields = append(fields, appinstance.FieldInstanceType)
	}
	if m.addinstaller != nil {
		fields = append(fields, appinstance.FieldInstaller)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appinstance.FieldStatus:
		return m.AddedStatus()
	case appinstance.FieldDelFlag:
		return m.AddedDelFlag()
	case appinstance.FieldInstancePackage:
		return m.AddedInstancePackage()
	case appinstance.FieldInstanceType:
		return m.AddedInstanceType()
	case appinstance.FieldInstaller:
		return m.AddedInstaller()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case appinstance.FieldDelFlag:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelFlag(v)
		return nil
	case appinstance.FieldInstancePackage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstancePackage(v)
		return nil
	case appinstance.FieldInstanceType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstanceType(v)
		return nil
	case appinstance.FieldInstaller:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstaller(v)
		return nil
	}
	return fmt.Errorf("unknown AppInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appinstance.FieldCreatedAt) {
		fields = append(fields, appinstance.FieldCreatedAt)
	}
	if m.FieldCleared(appinstance.FieldUpdatedAt) {
		fields = append(fields, appinstance.FieldUpdatedAt)
	}
	if m.FieldCleared(appinstance.FieldDeleteAt) {
		fields = append(fields, appinstance.FieldDeleteAt)
	}
	if m.FieldCleared(appinstance.FieldStatus) {
		fields = append(fields, appinstance.FieldStatus)
	}
	if m.FieldCleared(appinstance.FieldRemark) {
		fields = append(fields, appinstance.FieldRemark)
	}
	if m.FieldCleared(appinstance.FieldDelFlag) {
		fields = append(fields, appinstance.FieldDelFlag)
	}
	if m.FieldCleared(appinstance.FieldInstanceIcon) {
		fields = append(fields, appinstance.FieldInstanceIcon)
	}
	if m.FieldCleared(appinstance.FieldInstanceAddress) {
		fields = append(fields, appinstance.FieldInstanceAddress)
	}
	if m.FieldCleared(appinstance.FieldInstanceType) {
		fields = append(fields, appinstance.FieldInstanceType)
	}
	if m.FieldCleared(appinstance.FieldInstaller) {
		fields = append(fields, appinstance.FieldInstaller)
	}
	if m.FieldCleared(appinstance.FieldDesc) {
		fields = append(fields, appinstance.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppInstanceMutation) ClearField(name string) error {
	switch name {
	case appinstance.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case appinstance.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appinstance.FieldDeleteAt:
		m.ClearDeleteAt()
		return nil
	case appinstance.FieldStatus:
		m.ClearStatus()
		return nil
	case appinstance.FieldRemark:
		m.ClearRemark()
		return nil
	case appinstance.FieldDelFlag:
		m.ClearDelFlag()
		return nil
	case appinstance.FieldInstanceIcon:
		m.ClearInstanceIcon()
		return nil
	case appinstance.FieldInstanceAddress:
		m.ClearInstanceAddress()
		return nil
	case appinstance.FieldInstanceType:
		m.ClearInstanceType()
		return nil
	case appinstance.FieldInstaller:
		m.ClearInstaller()
		return nil
	case appinstance.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown AppInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppInstanceMutation) ResetField(name string) error {
	switch name {
	case appinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appinstance.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	case appinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case appinstance.FieldRemark:
		m.ResetRemark()
		return nil
	case appinstance.FieldDelFlag:
		m.ResetDelFlag()
		return nil
	case appinstance.FieldInstanceName:
		m.ResetInstanceName()
		return nil
	case appinstance.FieldInstanceCode:
		m.ResetInstanceCode()
		return nil
	case appinstance.FieldInstancePackage:
		m.ResetInstancePackage()
		return nil
	case appinstance.FieldInstanceIcon:
		m.ResetInstanceIcon()
		return nil
	case appinstance.FieldInstanceAddress:
		m.ResetInstanceAddress()
		return nil
	case appinstance.FieldInstanceType:
		m.ResetInstanceType()
		return nil
	case appinstance.FieldInstaller:
		m.ResetInstaller()
		return nil
	case appinstance.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown AppInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.installFrom != nil {
		edges = append(edges, appinstance.EdgeInstallFrom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appinstance.EdgeInstallFrom:
		if id := m.installFrom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstallFrom {
		edges = append(edges, appinstance.EdgeInstallFrom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case appinstance.EdgeInstallFrom:
		return m.clearedinstallFrom
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppInstanceMutation) ClearEdge(name string) error {
	switch name {
	case appinstance.EdgeInstallFrom:
		m.ClearInstallFrom()
		return nil
	}
	return fmt.Errorf("unknown AppInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppInstanceMutation) ResetEdge(name string) error {
	switch name {
	case appinstance.EdgeInstallFrom:
		m.ResetInstallFrom()
		return nil
	}
	return fmt.Errorf("unknown AppInstance edge %s", name)
}

// AppPackageMutation represents an operation that mutates the AppPackage nodes in the graph.
type AppPackageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete_at           *time.Time
	status              *int8
	addstatus           *int8
	pkg_name            *string
	pkg_code            *string
	pkg_version         *string
	pkg_type            *int8
	addpkg_type         *int8
	pkg_kind            *int8
	addpkg_kind         *int8
	uploader            *int64
	adduploader         *int64
	desc                *string
	remark              *string
	clearedFields       map[string]struct{}
	app_instance        map[int64]struct{}
	removedapp_instance map[int64]struct{}
	clearedapp_instance bool
	done                bool
	oldValue            func(context.Context) (*AppPackage, error)
	predicates          []predicate.AppPackage
}

var _ ent.Mutation = (*AppPackageMutation)(nil)

// apppackageOption allows management of the mutation configuration using functional options.
type apppackageOption func(*AppPackageMutation)

// newAppPackageMutation creates new mutation for the AppPackage entity.
func newAppPackageMutation(c config, op Op, opts ...apppackageOption) *AppPackageMutation {
	m := &AppPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPackageID sets the ID field of the mutation.
func withAppPackageID(id int64) apppackageOption {
	return func(m *AppPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPackage
		)
		m.oldValue = func(ctx context.Context) (*AppPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPackage sets the old AppPackage of the mutation.
func withAppPackage(node *AppPackage) apppackageOption {
	return func(m *AppPackageMutation) {
		m.oldValue = func(context.Context) (*AppPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("codegen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPackage entities.
func (m *AppPackageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPackageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPackageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPackageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPackageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppPackageMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apppackage.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppPackageMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPackageMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apppackage.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPackageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPackageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppPackageMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apppackage.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppPackageMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPackageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apppackage.FieldUpdatedAt)
}

// SetDeleteAt sets the "delete_at" field.
func (m *AppPackageMutation) SetDeleteAt(t time.Time) {
	m.delete_at = &t
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *AppPackageMutation) DeleteAt() (r time.Time, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldDeleteAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// ClearDeleteAt clears the value of the "delete_at" field.
func (m *AppPackageMutation) ClearDeleteAt() {
	m.delete_at = nil
	m.clearedFields[apppackage.FieldDeleteAt] = struct{}{}
}

// DeleteAtCleared returns if the "delete_at" field was cleared in this mutation.
func (m *AppPackageMutation) DeleteAtCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldDeleteAt]
	return ok
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *AppPackageMutation) ResetDeleteAt() {
	m.delete_at = nil
	delete(m.clearedFields, apppackage.FieldDeleteAt)
}

// SetStatus sets the "status" field.
func (m *AppPackageMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AppPackageMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AppPackageMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AppPackageMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AppPackageMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[apppackage.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppPackageMutation) StatusCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppPackageMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, apppackage.FieldStatus)
}

// SetPkgName sets the "pkg_name" field.
func (m *AppPackageMutation) SetPkgName(s string) {
	m.pkg_name = &s
}

// PkgName returns the value of the "pkg_name" field in the mutation.
func (m *AppPackageMutation) PkgName() (r string, exists bool) {
	v := m.pkg_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgName returns the old "pkg_name" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPkgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgName: %w", err)
	}
	return oldValue.PkgName, nil
}

// ResetPkgName resets all changes to the "pkg_name" field.
func (m *AppPackageMutation) ResetPkgName() {
	m.pkg_name = nil
}

// SetPkgCode sets the "pkg_code" field.
func (m *AppPackageMutation) SetPkgCode(s string) {
	m.pkg_code = &s
}

// PkgCode returns the value of the "pkg_code" field in the mutation.
func (m *AppPackageMutation) PkgCode() (r string, exists bool) {
	v := m.pkg_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgCode returns the old "pkg_code" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPkgCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgCode: %w", err)
	}
	return oldValue.PkgCode, nil
}

// ResetPkgCode resets all changes to the "pkg_code" field.
func (m *AppPackageMutation) ResetPkgCode() {
	m.pkg_code = nil
}

// SetPkgVersion sets the "pkg_version" field.
func (m *AppPackageMutation) SetPkgVersion(s string) {
	m.pkg_version = &s
}

// PkgVersion returns the value of the "pkg_version" field in the mutation.
func (m *AppPackageMutation) PkgVersion() (r string, exists bool) {
	v := m.pkg_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgVersion returns the old "pkg_version" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPkgVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgVersion: %w", err)
	}
	return oldValue.PkgVersion, nil
}

// ClearPkgVersion clears the value of the "pkg_version" field.
func (m *AppPackageMutation) ClearPkgVersion() {
	m.pkg_version = nil
	m.clearedFields[apppackage.FieldPkgVersion] = struct{}{}
}

// PkgVersionCleared returns if the "pkg_version" field was cleared in this mutation.
func (m *AppPackageMutation) PkgVersionCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldPkgVersion]
	return ok
}

// ResetPkgVersion resets all changes to the "pkg_version" field.
func (m *AppPackageMutation) ResetPkgVersion() {
	m.pkg_version = nil
	delete(m.clearedFields, apppackage.FieldPkgVersion)
}

// SetPkgType sets the "pkg_type" field.
func (m *AppPackageMutation) SetPkgType(i int8) {
	m.pkg_type = &i
	m.addpkg_type = nil
}

// PkgType returns the value of the "pkg_type" field in the mutation.
func (m *AppPackageMutation) PkgType() (r int8, exists bool) {
	v := m.pkg_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgType returns the old "pkg_type" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPkgType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgType: %w", err)
	}
	return oldValue.PkgType, nil
}

// AddPkgType adds i to the "pkg_type" field.
func (m *AppPackageMutation) AddPkgType(i int8) {
	if m.addpkg_type != nil {
		*m.addpkg_type += i
	} else {
		m.addpkg_type = &i
	}
}

// AddedPkgType returns the value that was added to the "pkg_type" field in this mutation.
func (m *AppPackageMutation) AddedPkgType() (r int8, exists bool) {
	v := m.addpkg_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearPkgType clears the value of the "pkg_type" field.
func (m *AppPackageMutation) ClearPkgType() {
	m.pkg_type = nil
	m.addpkg_type = nil
	m.clearedFields[apppackage.FieldPkgType] = struct{}{}
}

// PkgTypeCleared returns if the "pkg_type" field was cleared in this mutation.
func (m *AppPackageMutation) PkgTypeCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldPkgType]
	return ok
}

// ResetPkgType resets all changes to the "pkg_type" field.
func (m *AppPackageMutation) ResetPkgType() {
	m.pkg_type = nil
	m.addpkg_type = nil
	delete(m.clearedFields, apppackage.FieldPkgType)
}

// SetPkgKind sets the "pkg_kind" field.
func (m *AppPackageMutation) SetPkgKind(i int8) {
	m.pkg_kind = &i
	m.addpkg_kind = nil
}

// PkgKind returns the value of the "pkg_kind" field in the mutation.
func (m *AppPackageMutation) PkgKind() (r int8, exists bool) {
	v := m.pkg_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgKind returns the old "pkg_kind" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldPkgKind(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgKind: %w", err)
	}
	return oldValue.PkgKind, nil
}

// AddPkgKind adds i to the "pkg_kind" field.
func (m *AppPackageMutation) AddPkgKind(i int8) {
	if m.addpkg_kind != nil {
		*m.addpkg_kind += i
	} else {
		m.addpkg_kind = &i
	}
}

// AddedPkgKind returns the value that was added to the "pkg_kind" field in this mutation.
func (m *AppPackageMutation) AddedPkgKind() (r int8, exists bool) {
	v := m.addpkg_kind
	if v == nil {
		return
	}
	return *v, true
}

// ClearPkgKind clears the value of the "pkg_kind" field.
func (m *AppPackageMutation) ClearPkgKind() {
	m.pkg_kind = nil
	m.addpkg_kind = nil
	m.clearedFields[apppackage.FieldPkgKind] = struct{}{}
}

// PkgKindCleared returns if the "pkg_kind" field was cleared in this mutation.
func (m *AppPackageMutation) PkgKindCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldPkgKind]
	return ok
}

// ResetPkgKind resets all changes to the "pkg_kind" field.
func (m *AppPackageMutation) ResetPkgKind() {
	m.pkg_kind = nil
	m.addpkg_kind = nil
	delete(m.clearedFields, apppackage.FieldPkgKind)
}

// SetUploader sets the "uploader" field.
func (m *AppPackageMutation) SetUploader(i int64) {
	m.uploader = &i
	m.adduploader = nil
}

// Uploader returns the value of the "uploader" field in the mutation.
func (m *AppPackageMutation) Uploader() (r int64, exists bool) {
	v := m.uploader
	if v == nil {
		return
	}
	return *v, true
}

// OldUploader returns the old "uploader" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldUploader(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploader: %w", err)
	}
	return oldValue.Uploader, nil
}

// AddUploader adds i to the "uploader" field.
func (m *AppPackageMutation) AddUploader(i int64) {
	if m.adduploader != nil {
		*m.adduploader += i
	} else {
		m.adduploader = &i
	}
}

// AddedUploader returns the value that was added to the "uploader" field in this mutation.
func (m *AppPackageMutation) AddedUploader() (r int64, exists bool) {
	v := m.adduploader
	if v == nil {
		return
	}
	return *v, true
}

// ClearUploader clears the value of the "uploader" field.
func (m *AppPackageMutation) ClearUploader() {
	m.uploader = nil
	m.adduploader = nil
	m.clearedFields[apppackage.FieldUploader] = struct{}{}
}

// UploaderCleared returns if the "uploader" field was cleared in this mutation.
func (m *AppPackageMutation) UploaderCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldUploader]
	return ok
}

// ResetUploader resets all changes to the "uploader" field.
func (m *AppPackageMutation) ResetUploader() {
	m.uploader = nil
	m.adduploader = nil
	delete(m.clearedFields, apppackage.FieldUploader)
}

// SetDesc sets the "desc" field.
func (m *AppPackageMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AppPackageMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *AppPackageMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[apppackage.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AppPackageMutation) DescCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AppPackageMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, apppackage.FieldDesc)
}

// SetRemark sets the "remark" field.
func (m *AppPackageMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AppPackageMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AppPackage entity.
// If the AppPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPackageMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AppPackageMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[apppackage.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AppPackageMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[apppackage.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AppPackageMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, apppackage.FieldRemark)
}

// AddAppInstanceIDs adds the "app_instance" edge to the AppInstance entity by ids.
func (m *AppPackageMutation) AddAppInstanceIDs(ids ...int64) {
	if m.app_instance == nil {
		m.app_instance = make(map[int64]struct{})
	}
	for i := range ids {
		m.app_instance[ids[i]] = struct{}{}
	}
}

// ClearAppInstance clears the "app_instance" edge to the AppInstance entity.
func (m *AppPackageMutation) ClearAppInstance() {
	m.clearedapp_instance = true
}

// AppInstanceCleared reports if the "app_instance" edge to the AppInstance entity was cleared.
func (m *AppPackageMutation) AppInstanceCleared() bool {
	return m.clearedapp_instance
}

// RemoveAppInstanceIDs removes the "app_instance" edge to the AppInstance entity by IDs.
func (m *AppPackageMutation) RemoveAppInstanceIDs(ids ...int64) {
	if m.removedapp_instance == nil {
		m.removedapp_instance = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.app_instance, ids[i])
		m.removedapp_instance[ids[i]] = struct{}{}
	}
}

// RemovedAppInstance returns the removed IDs of the "app_instance" edge to the AppInstance entity.
func (m *AppPackageMutation) RemovedAppInstanceIDs() (ids []int64) {
	for id := range m.removedapp_instance {
		ids = append(ids, id)
	}
	return
}

// AppInstanceIDs returns the "app_instance" edge IDs in the mutation.
func (m *AppPackageMutation) AppInstanceIDs() (ids []int64) {
	for id := range m.app_instance {
		ids = append(ids, id)
	}
	return
}

// ResetAppInstance resets all changes to the "app_instance" edge.
func (m *AppPackageMutation) ResetAppInstance() {
	m.app_instance = nil
	m.clearedapp_instance = false
	m.removedapp_instance = nil
}

// Where appends a list predicates to the AppPackageMutation builder.
func (m *AppPackageMutation) Where(ps ...predicate.AppPackage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPackageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPackageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPackage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPackageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPackageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPackage).
func (m *AppPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPackageMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, apppackage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apppackage.FieldUpdatedAt)
	}
	if m.delete_at != nil {
		fields = append(fields, apppackage.FieldDeleteAt)
	}
	if m.status != nil {
		fields = append(fields, apppackage.FieldStatus)
	}
	if m.pkg_name != nil {
		fields = append(fields, apppackage.FieldPkgName)
	}
	if m.pkg_code != nil {
		fields = append(fields, apppackage.FieldPkgCode)
	}
	if m.pkg_version != nil {
		fields = append(fields, apppackage.FieldPkgVersion)
	}
	if m.pkg_type != nil {
		fields = append(fields, apppackage.FieldPkgType)
	}
	if m.pkg_kind != nil {
		fields = append(fields, apppackage.FieldPkgKind)
	}
	if m.uploader != nil {
		fields = append(fields, apppackage.FieldUploader)
	}
	if m.desc != nil {
		fields = append(fields, apppackage.FieldDesc)
	}
	if m.remark != nil {
		fields = append(fields, apppackage.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppackage.FieldCreatedAt:
		return m.CreatedAt()
	case apppackage.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppackage.FieldDeleteAt:
		return m.DeleteAt()
	case apppackage.FieldStatus:
		return m.Status()
	case apppackage.FieldPkgName:
		return m.PkgName()
	case apppackage.FieldPkgCode:
		return m.PkgCode()
	case apppackage.FieldPkgVersion:
		return m.PkgVersion()
	case apppackage.FieldPkgType:
		return m.PkgType()
	case apppackage.FieldPkgKind:
		return m.PkgKind()
	case apppackage.FieldUploader:
		return m.Uploader()
	case apppackage.FieldDesc:
		return m.Desc()
	case apppackage.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppackage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppackage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppackage.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	case apppackage.FieldStatus:
		return m.OldStatus(ctx)
	case apppackage.FieldPkgName:
		return m.OldPkgName(ctx)
	case apppackage.FieldPkgCode:
		return m.OldPkgCode(ctx)
	case apppackage.FieldPkgVersion:
		return m.OldPkgVersion(ctx)
	case apppackage.FieldPkgType:
		return m.OldPkgType(ctx)
	case apppackage.FieldPkgKind:
		return m.OldPkgKind(ctx)
	case apppackage.FieldUploader:
		return m.OldUploader(ctx)
	case apppackage.FieldDesc:
		return m.OldDesc(ctx)
	case apppackage.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown AppPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppackage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppackage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppackage.FieldDeleteAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	case apppackage.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apppackage.FieldPkgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgName(v)
		return nil
	case apppackage.FieldPkgCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgCode(v)
		return nil
	case apppackage.FieldPkgVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgVersion(v)
		return nil
	case apppackage.FieldPkgType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgType(v)
		return nil
	case apppackage.FieldPkgKind:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgKind(v)
		return nil
	case apppackage.FieldUploader:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploader(v)
		return nil
	case apppackage.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case apppackage.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPackageMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, apppackage.FieldStatus)
	}
	if m.addpkg_type != nil {
		fields = append(fields, apppackage.FieldPkgType)
	}
	if m.addpkg_kind != nil {
		fields = append(fields, apppackage.FieldPkgKind)
	}
	if m.adduploader != nil {
		fields = append(fields, apppackage.FieldUploader)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppackage.FieldStatus:
		return m.AddedStatus()
	case apppackage.FieldPkgType:
		return m.AddedPkgType()
	case apppackage.FieldPkgKind:
		return m.AddedPkgKind()
	case apppackage.FieldUploader:
		return m.AddedUploader()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppackage.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case apppackage.FieldPkgType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPkgType(v)
		return nil
	case apppackage.FieldPkgKind:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPkgKind(v)
		return nil
	case apppackage.FieldUploader:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploader(v)
		return nil
	}
	return fmt.Errorf("unknown AppPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppackage.FieldCreatedAt) {
		fields = append(fields, apppackage.FieldCreatedAt)
	}
	if m.FieldCleared(apppackage.FieldUpdatedAt) {
		fields = append(fields, apppackage.FieldUpdatedAt)
	}
	if m.FieldCleared(apppackage.FieldDeleteAt) {
		fields = append(fields, apppackage.FieldDeleteAt)
	}
	if m.FieldCleared(apppackage.FieldStatus) {
		fields = append(fields, apppackage.FieldStatus)
	}
	if m.FieldCleared(apppackage.FieldPkgVersion) {
		fields = append(fields, apppackage.FieldPkgVersion)
	}
	if m.FieldCleared(apppackage.FieldPkgType) {
		fields = append(fields, apppackage.FieldPkgType)
	}
	if m.FieldCleared(apppackage.FieldPkgKind) {
		fields = append(fields, apppackage.FieldPkgKind)
	}
	if m.FieldCleared(apppackage.FieldUploader) {
		fields = append(fields, apppackage.FieldUploader)
	}
	if m.FieldCleared(apppackage.FieldDesc) {
		fields = append(fields, apppackage.FieldDesc)
	}
	if m.FieldCleared(apppackage.FieldRemark) {
		fields = append(fields, apppackage.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPackageMutation) ClearField(name string) error {
	switch name {
	case apppackage.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apppackage.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apppackage.FieldDeleteAt:
		m.ClearDeleteAt()
		return nil
	case apppackage.FieldStatus:
		m.ClearStatus()
		return nil
	case apppackage.FieldPkgVersion:
		m.ClearPkgVersion()
		return nil
	case apppackage.FieldPkgType:
		m.ClearPkgType()
		return nil
	case apppackage.FieldPkgKind:
		m.ClearPkgKind()
		return nil
	case apppackage.FieldUploader:
		m.ClearUploader()
		return nil
	case apppackage.FieldDesc:
		m.ClearDesc()
		return nil
	case apppackage.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown AppPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPackageMutation) ResetField(name string) error {
	switch name {
	case apppackage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppackage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppackage.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	case apppackage.FieldStatus:
		m.ResetStatus()
		return nil
	case apppackage.FieldPkgName:
		m.ResetPkgName()
		return nil
	case apppackage.FieldPkgCode:
		m.ResetPkgCode()
		return nil
	case apppackage.FieldPkgVersion:
		m.ResetPkgVersion()
		return nil
	case apppackage.FieldPkgType:
		m.ResetPkgType()
		return nil
	case apppackage.FieldPkgKind:
		m.ResetPkgKind()
		return nil
	case apppackage.FieldUploader:
		m.ResetUploader()
		return nil
	case apppackage.FieldDesc:
		m.ResetDesc()
		return nil
	case apppackage.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown AppPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app_instance != nil {
		edges = append(edges, apppackage.EdgeAppInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPackageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apppackage.EdgeAppInstance:
		ids := make([]ent.Value, 0, len(m.app_instance))
		for id := range m.app_instance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedapp_instance != nil {
		edges = append(edges, apppackage.EdgeAppInstance)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPackageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apppackage.EdgeAppInstance:
		ids := make([]ent.Value, 0, len(m.removedapp_instance))
		for id := range m.removedapp_instance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp_instance {
		edges = append(edges, apppackage.EdgeAppInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPackageMutation) EdgeCleared(name string) bool {
	switch name {
	case apppackage.EdgeAppInstance:
		return m.clearedapp_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPackageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AppPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPackageMutation) ResetEdge(name string) error {
	switch name {
	case apppackage.EdgeAppInstance:
		m.ResetAppInstance()
		return nil
	}
	return fmt.Errorf("unknown AppPackage edge %s", name)
}
